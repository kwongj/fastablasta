#!/usr/bin/env python
# Script by Jason Kwong
# Python BLASTN wrapper

# Use modern print function from python 3.x
from __future__ import print_function

# Modules
import argparse
from argparse import RawTextHelpFormatter
import sys
import os
from Bio.Blast.Applications import NcbiblastnCommandline

# Standard functions
# Log a message to stderr
def msg(*args, **kwargs):
	print(*args, file=sys.stderr, **kwargs)

# Log an error to stderr and quit with non-zero error code
def err(*args, **kwargs):
	msg(*args, **kwargs)
	sys.exit(1);

# Other functions
# Check files in FASTA format
def facheck(f):
	if os.path.isfile(f) == False:
		msg('ERROR: Cannot find "{}". Check file exists.'.format(f))
		return 1
	s = open(f, 'r')
	if s.read(1) != '>':
		msg('ERROR: "{}" does not appear to be in FASTA format.'.format(f))
		return 1
	s.close()

# Print header
sep = '\t'
def header():
	print('ID' + sep + 'QUERY' + sep + 'SEQUENCE' + sep + 'STRAND' + sep + 'IDENT' + sep + 'LENGTH' + sep + 'MISMATCH' + sep + 'GAPS' + sep + 'qSTART' + sep + 'qEND' + sep + 'sSTART' + sep + 'sEND' + sep + 'EVALUE' + sep + 'BITSCORE')

# Usage
parser = argparse.ArgumentParser(
	formatter_class=RawTextHelpFormatter,
	description='Searches a FASTA file for a specified query sequence using BLASTN',
	usage='\n  %(prog)s --query QUERY [OPTIONS] FASTA1 FASTA2 FASTA3 ... FASTAN > results.txt')
parser.add_argument('fasta', metavar='FASTA', nargs='+', help='FASTA file to search (required)')
parser.add_argument('--query', metavar='QUERY', required=True, help='query sequence to search for in FASTA format eg. rpoB, KPC-2 (required)')
parser.add_argument('--id', metavar='%ID', default='99', help='percentage identity cutoff (default=99)')
parser.add_argument('--evalue', metavar='EVALUE', default='1e-99', help='evalue cutoff (default=1e-99)')
parser.add_argument('--wordsize', metavar='SIZE', default='32', help='length of initial match (default=32)')
parser.add_argument('--short', action='store_true', help='allow searching for short sequences')
parser.add_argument('--outfmt', metavar='FORMAT', default='6', help='specify BLAST output format (default=6 tabular)')
parser.add_argument('--cpus', metavar='CPUS', default='1', help='number of CPUS to use (default=1)')
parser.add_argument('--version', action='version', version=
	'=====================================\n'
	'%(prog)s v0.2\n'
	'Updated 6-Jul-2016 by Jason Kwong\n'
	'Dependencies: Python 2.x, BioPython, BLAST\n'
	'=====================================')
args = parser.parse_args()

# Set blastn-short option if specified
if args.short:
	task = 'blastn-short'
	dust = 'no'
	if not args.wordsize:
		args.wordsize = '7'
	if not args.evalue:
		args.evalue = '1e-2'
else:
	task = 'blastn'
	dust = 'yes'

# Check query
if facheck(args.query) == 1:
	sys.exit(1)

# Set output format
if args.outfmt == '6':
	outFMT = "'6 qseqid sseqid sstrand pident length mismatch gapopen qstart qend sstart send evalue bitscore'"
	header()
else:
	outFMT = args.outfmt

# Run blastn
for f in args.fasta:
	if facheck(f) == 1:
		continue
	try:
		fBLAST = NcbiblastnCommandline(task=task, query=args.query, subject=f, evalue=args.evalue, perc_identity=args.id, outfmt=outFMT, num_threads=args.cpus, word_size=args.wordsize, dust=dust)
		stdout, stderr = fBLAST()
		if stdout:
			if args.outfmt == '6':
				BLASTout = stdout.split('\n')
				for line in BLASTout:
					if line.strip():
						lineOUT = ''.join(line)
						print(f + sep + lineOUT)
			else:
				print(stdout)
	except:
		sys.exit(1)
